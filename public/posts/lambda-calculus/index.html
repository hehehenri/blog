<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Functions Describe the World :: Henri Borges</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="A Quick Historical Context The lambda calculus was developed in the 1930s by the mathematician Alonzo Church, none other than the teacher of Alan Turing, atheist, homosexual, father of the computer science. It was introduced as a way to explore the foundations of mathematics and computation.
Introduction to the Lambda Calculus The title of the post is a quote from the introduction to Thomas Garrity&amp;rsquo;s &amp;ldquo;Mathematical Maturity&amp;rdquo; lecture (I recommend you watch it before continuing." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/lambda-calculus/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/green.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/green.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Functions Describe the World">
<meta property="og:description" content="A Quick Historical Context The lambda calculus was developed in the 1930s by the mathematician Alonzo Church, none other than the teacher of Alan Turing, atheist, homosexual, father of the computer science. It was introduced as a way to explore the foundations of mathematics and computation.
Introduction to the Lambda Calculus The title of the post is a quote from the introduction to Thomas Garrity&amp;rsquo;s &amp;ldquo;Mathematical Maturity&amp;rdquo; lecture (I recommend you watch it before continuing." />
<meta property="og:url" content="/posts/lambda-calculus/" />
<meta property="og:site_name" content="Henri Borges" />

  
  
  <meta property="og:image" content="/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2023-07-24 00:00:00 &#43;0000 UTC" />












</head>
<body class="green">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    henri borges
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href=""></a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="" ></a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/lambda-calculus/">Functions Describe the World</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-07-24</time><span class="post-reading-time">8 min read (1688 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="/tags/lambdacalculus/">lambdacalculus</a>&nbsp;
      
      #<a href="/tags/functionalprogramming/">functionalprogramming</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Table of Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#a-quick-historical-context">A Quick Historical Context</a></li>
    <li><a href="#introduction-to-the-lambda-calculus">Introduction to the Lambda Calculus</a></li>
    <li><a href="#currying">Currying</a></li>
    <li><a href="#binary-operations">Binary Operations</a></li>
    <li><a href="#church-numerals">Church Numerals</a></li>
    <li><a href="#arithmetic-operations">Arithmetic Operations</a></li>
    <li><a href="#recursion">Recursion</a></li>
    <li><a href="#final-thoughts">Final Thoughts</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="a-quick-historical-context">A Quick Historical Context<a href="#a-quick-historical-context" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The lambda calculus was developed in the 1930s by the mathematician <a href="https://wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>, none other than the teacher of <a href="https://wikipedia.org/wiki/Alan_Turing">Alan Turing</a>, atheist, homosexual, father of the computer science. It was introduced as a way to explore the foundations of mathematics and computation.</p>
<h2 id="introduction-to-the-lambda-calculus">Introduction to the Lambda Calculus<a href="#introduction-to-the-lambda-calculus" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The title of the post is a quote from the introduction to Thomas Garrity&rsquo;s <a href="https://www.youtube.com/watch?v=PAZTIAfaNr8">&ldquo;Mathematical Maturity&rdquo;</a> lecture (I recommend you watch it before continuing. It&rsquo;s 40 seconds long and very funny). This quote perfectly encapsulates the essence of the lambda calculus.</p>
<p>Keeping it short, the lambda calculus is a model of computation where the only thing you can do is define functions with one argument that returns another function (You can think of a function as a way to map an input to an output).</p>
<p>Even though it&rsquo;s simple, the lambda calculus is <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>, which means that if you give it enough time and resources, it can solve any solvable computational problem.</p>
<p>But how would we write a real program with only functions? What about branching and recursion? Well, you actually can do those things with just pure lambda calculus.</p>
<h2 id="currying">Currying<a href="#currying" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>But first, how we can use more than one value inside a function?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// Only one function with multiple arguments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span>(
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Multiple functions with only one argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>(<span style="color:#a6e22e">x</span> =&gt; (<span style="color:#a6e22e">y</span> =&gt; <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>)(<span style="color:#a6e22e">y</span>)
</span></span></code></pre></div><p>We can apply <a href="https://wiki.haskell.org/Beta_reduction">β reduction</a> to make things clear:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>((<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>))(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Multiple functions with only one argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>((<span style="color:#a6e22e">x</span> =&gt; (<span style="color:#a6e22e">y</span> =&gt; <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>))) <span style="color:#ae81ff">1</span>) <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">y</span> =&gt; <span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span>)) <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>This is a method called currying, named after some random guy called <a href="https://wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>, who invented it. It allows us to break down a function that takes multiple arguments into a chain of single-argument functions.</p>
<h2 id="binary-operations">Binary Operations<a href="#binary-operations" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Okay, but how do we make conditional operations, like <em>ifs</em> and <em>elses</em> ?</p>
<p>Let&rsquo;s define our booleans first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">True</span> <span style="color:#f92672">=</span> λx<span style="color:#f92672">.</span>λy<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">False</span> <span style="color:#f92672">=</span> λx<span style="color:#f92672">.</span>λy<span style="color:#f92672">.</span>y
</span></span></code></pre></div><p>Those are called <a href="https://en.wikipedia.org/wiki/Church_encoding">Church booleans</a>, abstractions that receive two arguments and, If <strong><em>True</em></strong>, the first argument is returned. If <strong><em>False</em></strong>, the second argument is returned.</p>
<p>With Church booleans in place, we can now simulate a branching behavior using Church booleans and abstractions.</p>
<p>Here&rsquo;s how you can define a conditional expression in lambda calculus:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">=</span> λcondition<span style="color:#f92672">.</span>λthen<span style="color:#f92672">.</span>λelse<span style="color:#f92672">.</span>(condition <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">else</span>)
</span></span></code></pre></div><p>The condition is represented as a parameter, one of the church booleans that will determine with of the branches will be returned.</p>
<p>You will get it when we reduce it again. Don&rsquo;t worry about the arithmetic operations, I&rsquo;ll talk about them later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">true</span> <span style="color:#f92672">=</span> λx<span style="color:#f92672">.</span>λy<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> true (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (((λcondition<span style="color:#f92672">.</span>λthen<span style="color:#f92672">.</span>λelse<span style="color:#f92672">.</span>(condition <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">else</span>)) true) (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> ((λthen<span style="color:#f92672">.</span>λelse<span style="color:#f92672">.</span>(true <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">else</span>)) (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>(λelse<span style="color:#f92672">.</span>(true (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">else</span>)) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> true (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> ((λx<span style="color:#f92672">.</span>λy<span style="color:#f92672">.</span>x) (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λy<span style="color:#f92672">.</span>(sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)) (mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (sum <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">4</span>
</span></span></code></pre></div><h2 id="church-numerals">Church Numerals<a href="#church-numerals" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The most popular way to represent natural numbers in lambda calculus is using the <strong>Church numerals</strong> encoding. In summary, the definition of the numeral <strong><em>N,</em></strong> is the application of a given function <strong><em>F</em></strong> <strong><em>N</em></strong> times to a given value.</p>
<p>Here is a small list of definitions, from 0-3.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f x
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f (f x)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f (f (f x))
</span></span></code></pre></div><p>Let&rsquo;s use the definition of <em>3</em> for example. If you think about it, in most cases, the result of <code>λf.λx.f (f (f x))</code> will not be the number three, unless the function we are providing is the <strong><em>succ</em></strong> (as defined below) and the <em>0</em> numeral as the value.</p>
<p>This is simply a way of doing something three times, which means that not the result, but the function itself is the church numeral three.</p>
<p>But how do we get the successor of a numeral?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">succ</span> <span style="color:#f92672">=</span> λn<span style="color:#f92672">.</span>λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f (n f x)
</span></span></code></pre></div><p>The <strong><em>succ</em></strong> function works by applying <strong><em>f</em></strong> to <strong><em>x</em></strong> one more time, returning the definition of the Church numeral that represents the successor of <em>n.</em></p>
<p>If you reached this point, you should be able to apply reduction to <strong><em>succ 3</em></strong> and confirm this by yourself. It&rsquo;s fun, I promise!</p>
<h2 id="arithmetic-operations">Arithmetic Operations<a href="#arithmetic-operations" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Now that we have numbers, we should be able to operate over them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> λm<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>m succ n
</span></span></code></pre></div><p>At this point, we are already composing functions. A good way to explain what&rsquo;s happening on the <code>add</code> definition is that we are applying <strong><em>succ</em></strong> to <em>n</em> <em>m</em> times.</p>
<p>Let&rsquo;s partially reduce it to make things clear:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> λm<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>m succ n
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f (f x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> ((λm<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>m succ n) <span style="color:#ae81ff">2</span>) <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λn<span style="color:#f92672">.</span><span style="color:#ae81ff">2</span> succ n) <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">2</span> succ <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> ((λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f (f x)) succ) <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λx<span style="color:#f92672">.</span>succ (succ x)) <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> succ (succ <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>We applied <strong><em>succ</em></strong> at <em>1</em> two times, which evaluates to <em>3</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">mult</span> <span style="color:#f92672">=</span> λm<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>m (add n) <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mult</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> ((λm<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>m (add n) <span style="color:#ae81ff">0</span>) <span style="color:#ae81ff">2</span>) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λn<span style="color:#f92672">.</span><span style="color:#ae81ff">2</span> (add n) <span style="color:#ae81ff">0</span>) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">2</span> (add <span style="color:#ae81ff">3</span>) <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> ((λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>f (f x)) (add <span style="color:#ae81ff">3</span>)) <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λx<span style="color:#f92672">.</span>(add <span style="color:#ae81ff">3</span>) ((add <span style="color:#ae81ff">3</span>) x)) <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (add <span style="color:#ae81ff">3</span>) (add <span style="color:#ae81ff">3</span>) <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (add <span style="color:#ae81ff">3</span>) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">6</span>
</span></span></code></pre></div><p>The multiplication function is as simple as applying addition to <strong><em>m</em> <em>n</em></strong> times. Similar to what we did on the <strong><em>add</em></strong> definition.</p>
<p>Opposite to the successor function, we also have the predecessor function. We&rsquo;ll also need it to be able to subtract numbers.</p>
<p>Predecessor is defined by the following formula:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">pred</span> <span style="color:#f92672">=</span> λn<span style="color:#f92672">.</span>λf<span style="color:#f92672">.</span>λx<span style="color:#f92672">.</span>n (λg<span style="color:#f92672">.</span>λh<span style="color:#f92672">.</span>h (g f)) (λu<span style="color:#f92672">.</span>x) (λu<span style="color:#f92672">.</span>u)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub</span> <span style="color:#f92672">=</span> λm<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>n pred m
</span></span></code></pre></div><p>I won&rsquo;t write the reduction for this case to keep things short, but again, we are just applying <strong><em>pred</em></strong> to <strong><em>m</em> <em>n</em></strong> times. You can take a look at <strong><em>add</em></strong> reduction if you are confused.</p>
<h2 id="recursion">Recursion<a href="#recursion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Recursion is a powerful concept in programming languages. Even lambda calculus being extremely simple, we can still use some tricks to achieve recursion.</p>
<p>But what is recursion? Take a look at this factorial example in javascript:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fact</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">n</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">fact</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What makes <strong><em>fact</em></strong> interesting to us is the fact that it calls itself. That&rsquo;s recursion! Unfortunately, there isn&rsquo;t a direct way of achieving recursion directly.</p>
<p>We&rsquo;ll need to use a little trick called the Y combinator (I&rsquo;m not talking about Silicon Valley&rsquo;s <a href="https://www.ycombinator.com/">Y Combinator</a>, but the fixed-point one).</p>
<p>The Y combinator takes a function as an argument and returns a fixed-point of that function. In other words, it enables self-reference within a function. Don&rsquo;t worry, I&rsquo;ll explain what a fixed-point is and why it works later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">Y</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>(λx<span style="color:#f92672">.</span>f (x x)) (λx<span style="color:#f92672">.</span>f (x x))
</span></span></code></pre></div><p>Let&rsquo;s write the factorial function in the lambda calculus syntax, so we can see the Y in action:</p>
<pre tabindex="0"><code>fact = λf.λn.(
   if eq(n 0) then 
        1 
    else 
        (mult n (f (sub n 1))))
</code></pre><p>The definition of <em>fact</em> is perfect, but how can we call it? <em>f</em> should be the <em>fact</em> function itself. Can you think of a way to reference it?</p>
<p>First, let&rsquo;s see a fixed-point in action:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">Y</span> g <span style="color:#f92672">=</span> (λf<span style="color:#f92672">.</span>(λx<span style="color:#f92672">.</span>f (x x)) (λx<span style="color:#f92672">.</span>f (x x))) g
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λx<span style="color:#f92672">.</span>g (x x)) (λx<span style="color:#f92672">.</span>g (x x))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> g ((λx<span style="color:#f92672">.</span>g (x x)) (λx<span style="color:#f92672">.</span>g (x x)))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> g (<span style="color:#66d9ef">Y</span> g)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>That&rsquo;s why <strong><em>Y</em></strong> is called a fixed-point. Regardless of the value of the function <strong><em>g</em></strong>, <strong><em>Y</em></strong> is still the same.</p>
<p>Well, given that, how does this fix the issue with the <strong><em>f</em></strong> parameter on the <strong><em>fact</em></strong> function? Let&rsquo;s plug both things together:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> (λf<span style="color:#f92672">.</span><span style="color:#66d9ef">G</span> <span style="color:#f92672">=</span> λf<span style="color:#f92672">.</span>(λx<span style="color:#f92672">.</span>f (x x)) (λx<span style="color:#f92672">.</span>f (x x)) fact) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> ((λx<span style="color:#f92672">.</span>fact (x x)) (λx<span style="color:#f92672">.</span>fact (x x))) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> fact ((λx<span style="color:#f92672">.</span>fact (x x)) (λx<span style="color:#f92672">.</span>fact (x x))) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> fact (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>Wait, that was it? Yes! That&rsquo;s exactly what we needed as an argument to the <strong><em>f</em></strong> parameter on <strong><em>fact</em></strong>. A reference to itself. We can keep reducing to see if it will work (Don&rsquo;t run away, please! Read it slowly and I promise it will make sense):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">fact</span> (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">3</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (λf<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>(<span style="color:#66d9ef">if</span> (eq n <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult n (f (sub n <span style="color:#ae81ff">1</span>))))) (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">if</span> (eq <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult <span style="color:#ae81ff">3</span> ((<span style="color:#66d9ef">Y</span> fact) (sub <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> (mult <span style="color:#ae81ff">3</span> ((<span style="color:#66d9ef">Y</span> fact) (sub <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1</span>)))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (fact (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (λf<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>(<span style="color:#66d9ef">if</span> (eq n <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult n (f (sub n <span style="color:#ae81ff">1</span>))))) (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (<span style="color:#66d9ef">if</span> (eq <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult <span style="color:#ae81ff">2</span> ((<span style="color:#66d9ef">Y</span> fact) (sub <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> ((<span style="color:#66d9ef">Y</span> fact) (sub <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> ((<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> (fact (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> ((λf<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>(<span style="color:#66d9ef">if</span> (eq n <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult n (f (sub n <span style="color:#ae81ff">1</span>))))) (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> ((<span style="color:#66d9ef">if</span> (eq <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult <span style="color:#ae81ff">1</span> ((<span style="color:#66d9ef">Y</span> fact) (sub <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">1</span>))))))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> (mult <span style="color:#ae81ff">1</span> ((<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">0</span>)))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> (mult <span style="color:#ae81ff">1</span> (fact (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">0</span>)))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> (mult <span style="color:#ae81ff">1</span> ((λf<span style="color:#f92672">.</span>λn<span style="color:#f92672">.</span>(<span style="color:#66d9ef">if</span> eq(n <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult n (f (sub n <span style="color:#ae81ff">1</span>))))) (<span style="color:#66d9ef">Y</span> fact) <span style="color:#ae81ff">0</span>)))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> (mult <span style="color:#ae81ff">1</span> ((<span style="color:#66d9ef">if</span> (eq <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> (mult n ((<span style="color:#66d9ef">Y</span> fact) (sub n <span style="color:#ae81ff">1</span>)))))))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> (mult <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> (mult <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> mult <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">6</span>
</span></span></code></pre></div><p>And that&rsquo;s how you achieve recursion in pure lambda calculus.</p>
<h2 id="final-thoughts">Final Thoughts<a href="#final-thoughts" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The lambda calculus, a foundational concept in mathematics and computer science, provides a way of expressing computation using only functions. It shows the elegance and versatility of functional programming, proving its capability to solve complex problems with simplicity.
It continues to influence modern programming paradigms, making it a timeless and fundamental concept in the realm of computation.</p>
<p>If you made it this far and are still interested, you can see on <a href="https://github.com/hnrbs/lambda-calculus">this repository</a> an actual implementation of the lambda calculus.</p>
<hr>
<p>References:</p>
<ul>
<li><a href="https://wikipedia.org/wiki/Lambda_calculus">https://wikipedia.org/wiki/Lambda_calculus</a></li>
<li><a href="https://wikipedia.org/wiki/Church_encoding">https://wikipedia.org/wiki/Church_encoding</a></li>
<li><a href="https://wikipedia.org/wiki/Fixed-point_combinator">https://wikipedia.org/wiki/Fixed-point_combinator</a></li>
</ul>

      </div></div>

  
    
  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2023 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
